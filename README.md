# üí° Learning about SOLID Principles & Clean Code üíª

## üåü Overview
Welcome to the **Learning about SOLID Principles & Clean Code** project!

This repository is dedicated to learning and understanding two fundamental concepts in software development: SOLID principles and clean code practices.

**SOLID principles** are a set of five design principles in object-oriented programming intended to make software designs more understandable, flexible, and maintainable. Each principle addresses a different aspect of software design and, when applied together, they help create more robust and scalable software systems.

**Clean code** refers to writing code that is easy to understand, read, and maintain. It emphasizes clarity, simplicity, and consistency in coding practices, making it easier for developers to collaborate and for projects to evolve over time.

---

## Contents
In this repository, you will find:

- üìö Resources: Articles, tutorials, and other learning materials related to SOLID principles and clean code practices.
- üíª Examples: Code examples illustrating how to apply SOLID principles and write clean, maintainable code in various programming languages.
- üìù License: Information about the project's license.

Whether you're a beginner looking to understand the basics or an experienced developer striving for mastery, this repository aims to provide valuable resources and insights to help you level up your software development skills.

Feel free to explore and engage with the content. Happy coding! üöÄ

---

## Resources
- [SOLID Principles Explained](https://www.freecodecamp.org/news/solid-principles-explained-in-plain-english/)
- [Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [Refactoring.Guru](https://refactoring.guru/): Refactoring.Guru makes it easy for you to discover everything you need to know about refactoring, design patterns, SOLID principles, and other smart programming topics. This site shows you the big picture, how all these subjects intersect, work together, and are still relevant. I don‚Äôt pretend to be the inventor of these concepts‚Äîmost of them were invented by others during the past 20 years. But I think that the connection between refactoring, patterns and general programming principles still remains a mystery for the majority of programmers. This is the problem I would like to solve here.

## SOLID Principles and Managing Technical Debt

### Technical Debt
Technical debt refers to the short-term compromises that a development team makes by opting for a quick solution instead of applying a more robust and sustainable one. This debt can accumulate over time and negatively impact the software quality.

### Single Responsibility Principle (SRP)
A class should have only one reason to change. This means that each class should have a single responsibility or task within the system, making it easier to understand, maintain, and reuse.

### Open/Closed Principle (OCP)
Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This is achieved by designing software components in a way that they can be extended with new functionalities without altering their source code.

### Liskov Substitution Principle (LSP)
Subtypes must be substitutable for their base types without changing the program's behavior. This implies that objects of a base class can be replaced by objects of a derived class without affecting the system's integrity.

### Interface Segregation Principle (ISP)
Clients should not be forced to depend on interfaces they do not use. In other words, it is preferable to have more specific interfaces than a single general interface. This prevents classes from depending on methods they do not need.

### Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules; both should depend on abstractions. Additionally, abstractions should not depend on details, but details should depend on abstractions. This promotes the creation of flexible and easy-to-maintain systems by reducing coupling between components.

## License
This project is licensed under the [MIT License](LICENSE) - see the [LICENSE](LICENSE) file for details.
